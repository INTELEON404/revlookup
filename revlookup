#!/usr/bin/env python3
"""
Mod By: INTELEON404
GitHub: https://github.com/INTELEON404
"""

import argparse
import socket
import threading
import ipaddress
import re
import sys
from pathlib import Path

# ==================== YOUR ART + CREDITS ====================
print("""
┏━┓┏━╸╻ ╻╻  ┏━┓┏━┓╻┏ ╻ ╻┏━┓
┣┳┛┣╸ ┃┏┛┃  ┃ ┃┃ ┃┣┻┓┃ ┃┣━┛
╹┗╸┗━╸┗┛ ┗━╸┗━┛┗━┛╹ ╹┗━┛╹  

          Dev By: HunterDep
          Mod By: INTELEON404
          GitHub: https://github.com/INTELEON404
""")
# ===========================================================

seen = set()
seen_lock = threading.Lock()

def to_ips(target: str) -> list[str]:
    target = target.strip()
    if re.fullmatch(r"\d{1,3}(\.\d{1,3}){3}", target):
        return [target]
    try:
        return list({ip for ip in socket.gethostbyname_ex(target)[2]})
    except:
        return []

def rev(ip: str) -> str | None:
    try:
        return socket.gethostbyaddr(ip)[0]
    except:
        return None

def worker(ip: str, out_file: Path | None, unique: bool):
    name = rev(ip)
    if not name:
        return
    if unique:
        with seen_lock:
            if name in seen:
                return
            seen.add(name)
    print(name)
    if out_file:
        with open(out_file, "a", encoding="utf-8") as f:
            f.write(name + "\n")

def main():
    parser = argparse.ArgumentParser(
        prog="revlookup",
        description="RevLookup v2.1 — INTELEON404",
        add_help=False,
        formatter_class=argparse.RawTextHelpFormatter,
        usage="revlookup (-t TARGET | -f FILE | -c CIDR) [-o OUTPUT] [-u] [-td N] [-h]"
    )

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-t", "--target", metavar="TARGET", help="Single IP or domain")
    group.add_argument("-f", "--file", metavar="FILE", help="File with targets")
    group.add_argument("-c", "--cidr", metavar="CIDR", help="CIDR range")

    parser.add_argument("-o", "--output", metavar="OUTPUT", help="Save results to file")
    parser.add_argument("-u", "--unique", action="store_true", help="Show only unique hostnames")
    parser.add_argument("-td", "--threads", type=int, default=404, metavar="N", help="Max threads (default: 404)")
    parser.add_argument("-h", "--help", action="help", help="show this help message and exit")

    args = parser.parse_args()

    targets = []

    if args.target:
        targets = to_ips(args.target)
    elif args.cidr:
        try:
            targets = [str(ip) for ip in ipaddress.ip_network(args.cidr, strict=False).hosts()]
        except:
            sys.exit(1)
    elif args.file:
        path = Path(args.file)
        if not path.exists():
            sys.exit(1)
        for line in path.read_text().splitlines():
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            if "/" in line:
                try:
                    targets.extend(str(ip) for ip in ipaddress.ip_network(line, strict=False).hosts())
                except:
                    continue
            else:
                targets.extend(to_ips(line))

    if not targets:
        sys.exit(0)

    out = Path(args.output).expanduser() if args.output else None
    if out:
        out.write_text("", encoding="utf-8")

    thread_count = max(1, min(5000, args.threads))
    sem = threading.Semaphore(thread_count)
    threads = []

    for ip in targets:
        with sem:
            t = threading.Thread(target=worker, args=(ip, out, args.unique))
            t.daemon = True
            t.start()
            threads.append(t)

    for t in threads:
        t.join()

if __name__ == "__main__":
    if len(sys.argv) == 1 or "-h" in sys.argv or "--help" in sys.argv:
        main()
    else:
        main()